<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web 3D实时渲染引擎（引擎架构测试）</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: #222;
        }
        #glCanvas {
            position: absolute;
            left: 0; top: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            z-index: 0;
        }
        .toolbar {
            position: absolute;
            left: 0;
            top: 60px; /* 避开标题栏 */
            width: 56px;
            height: calc(100vh - 60px);
            background: rgba(30, 30, 30, 0.6);
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 0;
        }
        .toolbar button {
            width: 40px;
            height: 40px;
            margin: 8px 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(80, 80, 80, 0.7);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            color: #fff;
            transition: background 0.2s;
        }
        .toolbar button.active {
            background: #2196f3;
        }
        .toolbar button:hover {
            background: #1976d2;
        }
        .toolbar hr {
            width: 80%;
            border: 0;
            border-top: 1px solid #444;
            margin: 12px 0;
        }
        .titlebar {
            position: absolute;
            left: 0; top: 0;
            width: 100vw;
            height: 60px;
            background: rgba(40, 40, 40, 0.7);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            z-index: 3;
            letter-spacing: 2px;
            user-select: none;
        }
        .outline-panel {
            position: absolute;
            right: 0; top: 60px;
            width: 260px;
            height: calc(100vh - 60px);
            background: rgba(30, 30, 30, 0.6);
            z-index: 2;
            padding: 16px 8px;
            overflow-y: auto;
        }
        .outline-title {
            color: #fff;
            font-size: 18px;
            margin-bottom: 12px;
            font-weight: bold;
            letter-spacing: 1px;
        }
        .tree {
            color: #fff;
            font-size: 15px;
            list-style: none;
            padding-left: 0;
        }
        .tree, .tree ul, .tree ol {
            list-style: none;
            padding-left: 0;
            margin-left: 0;
        }
        .tree li {
            margin-bottom: 6px;
            padding-left: 14px; /* 稍微大一点，避免和蓝点重叠 */
            position: relative;
        }
        .tree li:before {
            content: "•";
            position: absolute;
            left: 0;
            color: #2196f3;
            font-size: 18px;
            line-height: 1;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas" tabindex="0"></canvas>
    <div class="titlebar">
        Web 3D实时渲染引擎（引擎架构测试）
    </div>
    <div class="toolbar">
        <button id="btn-webgl" title="WebGL渲染器"><span class="material-icons">memory</span></button>
        <button id="btn-webgpu" title="WebGPU渲染器"><span class="material-icons">developer_board</span></button>
        <hr>
        <button id="btn-orbit" title="轨道控制器"><span class="material-icons">360</span></button>
        <button id="btn-fps" title="第一人称控制器"><span class="material-icons">person</span></button>
    </div>
    <div class="outline-panel">
        <div class="outline-title">世界大纲</div>
        <ul id="model-tree" class="tree">
            <!-- 动态插入模型节点 -->
        </ul>
    </div>
    <script type="module">
        import iEngine from '../dist/iengine.js'

        /**
         * 创建一个红色的三角形实体
         */
        function createTriangleEntity() {
            // 创建实体
            const triangleEntity = new iEngine.Node('Triangle');
            
            // 创建网格
            const triangleMesh = new iEngine.Mesh(
                new iEngine.Triangle(),
                new iEngine.Primitive(
                    iEngine.PrimitiveType.TRIANGLES,
                    {
                        arrayStride: 12,
                        attributes: [
                            {
                                name: 'aPosition',
                                format: 'float32x3',
                                offset: 0,
                                shaderLocation: 0
                            }
                        ]
                    },
                )
            );

            // 创建材质
            const material = new iEngine.BaseMaterial({
                shaderName: 'base_material'
            });
            material.setColor(1.0, 0.0, 0.0); // 红色

            // 创建渲染组件并添加到实体
            const renderableComponent = new iEngine.RenderableComponent(
                triangleMesh, 
                material, 
                iEngine.RenderLayerID.Opaque
            );
            triangleEntity.addComponent(renderableComponent);

            return triangleEntity;
        }

        /**
         * 创建一个立方体实体
         */
        function createCubeEntity() {
            // 创建实体
            const cubeEntity = new iEngine.Node('Cube');
            
            // 创建网格
            const cubeMesh = new iEngine.Mesh(
                new iEngine.Cube(),
                new iEngine.Primitive(
                    iEngine.PrimitiveType.TRIANGLES,
                    // 网格数据保持不变
                )
            );

            // 创建PBR材质
            const cubeMaterial = new iEngine.PbrMaterial({
                shaderName: 'base_pbr',
                baseColor: new iEngine.Color(1.0, 1.0, 1.0),
                baseColorMap: '../../assets/textures/Wood048_1K-PNG/Wood048_1K-PNG_Color.png',
                metallic: 0.8,
                roughness: 0.02
            });

            // 创建渲染组件并添加到实体
            const renderableComponent = new iEngine.RenderableComponent(
                cubeMesh, 
                cubeMaterial, 
                iEngine.RenderLayerID.Opaque
            );
            cubeEntity.addComponent(renderableComponent);
            
            return cubeEntity;
        }

        /**
         * 创建一个黄色线框立方体实体
         */
        function createWireframeCubeEntity() {
            // 创建实体
            const wireframeCubeEntity = new iEngine.Node('CubeWireframe');
            
            // 创建网格
            const wireframeCubeMesh = new iEngine.Mesh(
                new iEngine.Cube(),
                new iEngine.Primitive(
                    iEngine.PrimitiveType.LINES,
                    // 网格数据保持不变
                )
            );
            
            // 创建线框材质
            const wireframeMaterial = new iEngine.BaseMaterial({
                shaderName: 'base_material'
            });
            wireframeMaterial.setColor(1.0, 1.0, 0.0); // 黄色
            
            // 创建渲染组件并添加到实体
            const renderableComponent = new iEngine.RenderableComponent(
                wireframeCubeMesh, 
                wireframeMaterial, 
                iEngine.RenderLayerID.Opaque
            );
            wireframeCubeEntity.addComponent(renderableComponent);
            
            return wireframeCubeEntity;
        }

        // 1. 初始化引擎
        const engine = new iEngine.Engine(/*canvas, {
            renderer: 'webgpu',
            webGLOptions: {
                useWebGL1: true, // 默认使用 WebGL2 渲染器
                attrs: {
                    antialias: true, // 开启抗锯齿
                    alpha: true, // 开启透明背景
                }
            }
        }*/);

        // 2. 启动引擎（可以在 Engine 实例化后，立即通过 start 方法启动引擎）
        // await engine.start();

        const canvas = document.getElementById('glCanvas');

        // 3. 创建场景
        const scene = new iEngine.Scene();
        const minimapScene = new iEngine.Scene();

        // 4. 创建相机
        const camera = new iEngine.PerspectiveCamera(60, canvas.width / canvas.height, 0.1, 1000);
        camera.setPosition(0, 0, 5);
        camera.lookAt(0, 0, 0);
        // 设置场景的相机
        scene.activeCamera = camera;
        
        minimapScene.activeCamera = camera;

        // 5. 创建相机的控制器
        let controls = new iEngine.OrbitControls(camera, canvas);

        // 6. 添加光源组件（ECS方式）
        // 添加环境光
        const ambientLight = new iEngine.AmbientLight({
            color: new iEngine.Color(0.3, 0.3, 0.3)
        });
        const ambientLightEntity = new iEngine.Node('AmbientLight');
        const ambientLightComponent = new iEngine.LightComponent(ambientLight);
        ambientLightEntity.addComponent(ambientLightComponent);
        scene.addEntity(ambientLightEntity);
        minimapScene.addEntity(ambientLightEntity);

        // 添加平行光
        const directionalLight = new iEngine.DirectionalLight({
            color: new iEngine.Color(1.0, 1.0, 1.0),
            intensity: 5.0
        });
        const directionalLightEntity = new iEngine.Node('DirectionalLight');
        const directionalLightComponent = new iEngine.LightComponent(directionalLight);
        directionalLightEntity.addComponent(directionalLightComponent);
        scene.addEntity(directionalLightEntity);
        minimapScene.addEntity(directionalLightEntity);
        
        // 7. 创建ECS实体并添加到场景中
        const triangleEntity = createTriangleEntity();
        const cubeEntity = createCubeEntity();
        const wireframeCubeEntity = createWireframeCubeEntity();
        // 将实体添加到场景
        scene.addEntity(triangleEntity);
        scene.addEntity(cubeEntity);
        // scene.addEntity(wireframeCubeEntity); // 线框移至小地图

        minimapScene.addEntity(cubeEntity);
        minimapScene.addEntity(wireframeCubeEntity);

        // 将场景添加到引擎
        // engine.addScene('simple-scene', scene);

        // const renderer = engine.createRenderer('webgl');
        const renderer = new iEngine.WebGLRenderer();
        // const renderer = new iEngine.WebGPURenderer();
        // const webGPURenderer = new iEngine.WebGPURenderer();

        // 创建共享的渲染器实例（避免多个渲染器冲突）
        const sharedRenderer = new iEngine.WebGLRenderer();

        const mainView = new iEngine.RenderView({
            canvas,
            scene: scene,
            camera: camera,
            renderer: sharedRenderer,
            // 主视图占据整个canvas
            viewport: { x: 0, y: 0, width: canvas.clientWidth, height: canvas.clientHeight },
            clearColor: [0.1, 0.1, 0.1, 1]
        });

        const minimapView = new iEngine.RenderView({
            canvas,
            scene: minimapScene,
            camera: camera,
            renderer: sharedRenderer,
            // 小地图视图在右下角，200x150像素
            // 计算逻辑:
            // x = canvas.clientWidth - (viewport.width + marginRight)
            // y = canvas.clientHeight - (viewport.height + marginBottom)
            // 这里的 viewport.width = 200 ， viewport.height = 150 ，边距取约 20 像素。
            // viewport: { x: canvas.clientWidth - 220, y: canvas.clientHeight - 170, width: 200, height: 150 },
            viewport: { x: 70, y: 10, width: 200, height: 150 },
            clearColor: [0.2, 0.2, 0.2, 1]  // 稍微不同的背景色以区分
        });

        await mainView.init();
        await minimapView.init();

        // 8. 控制渲染循环（ECS架构方式）
        engine.setAnimationLoop(() => {
            // 引擎标准的帧渲染更新（会自动更新所有实体）
            // engine.tick();
            
            // 先渲染主视图（全屏清屏）
            mainView.render();
            
            // 再渲染小地图视图（不清屏，叠加渲染）
            minimapView.render();
        });

        // 工具栏按钮事件
        document.getElementById('btn-webgl').onclick = async () => {
            await engine.setRenderer('webgl');
            document.getElementById('btn-webgl').classList.add('active');
            document.getElementById('btn-webgpu').classList.remove('active');
        };
        document.getElementById('btn-webgpu').onclick = async () => {
            await engine.setRenderer('webgpu');
            document.getElementById('btn-webgpu').classList.add('active');
            document.getElementById('btn-webgl').classList.remove('active');
        };
        document.getElementById('btn-orbit').onclick = () => {
            if (controls && controls.dispose) controls.dispose();
            controls = new iEngine.OrbitControls(camera, canvas);
            document.getElementById('btn-orbit').classList.add('active');
            document.getElementById('btn-fps').classList.remove('active');
        };
        document.getElementById('btn-fps').onclick = () => {
            if (controls && controls.dispose) controls.dispose();
            controls = new iEngine.FirstPersonControls(camera, canvas);
            document.getElementById('btn-fps').classList.add('active');
            document.getElementById('btn-orbit').classList.remove('active');
        };

        // 世界大纲树组件
        const componentTree = document.getElementById('model-tree');
        function renderComponentlTree(node) {
            const ul = document.createElement('ul');
            const li = document.createElement('li');
            li.textContent = node.name || node.constructor.name;
            ul.appendChild(li);

            if (typeof node.getComponents === 'function') {
                const components = node.getComponents();
                components?.forEach(comp => {
                    li.appendChild(renderComponentlTree(comp));
                });
            }
           
            return ul;
        }

        function updateComponentTree() {
            componentTree.innerHTML = '';
            componentTree.appendChild(renderComponentlTree(scene));
        }

        //
        updateComponentTree();

        // // 假设你有 addComponent/removeComponent 事件，可以这样监听并更新大纲
        // const origAdd = scene.addComponent.bind(scene);
        // scene.addComponent = function(comp) {
        //     origAdd(comp);
        //     updateModelTree();
        // };
        // const origRemove = scene.removeComponent?.bind(scene);
        // if (origRemove) {
        //     scene.removeComponent = function(comp) {
        //         origRemove(comp);
        //         updateModelTree();
        //     };
        // }
    </script>
</body>
</html>